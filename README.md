# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh
# the-fast-pizza-completed


Hey everybody, welcome to Algo Expert. In this video, we're going to answer the following behavioral interview question.

How would you go about distributing work for a project across a team of software engineers?

If you've led a project in the past, describe what you did.

So, I think that the first thing I would do, which is the first thing that you probably should do if you're trying to distribute work across a team of engineers, is to scope out the work.

It's very important for you to understand what it is exactly that you're building and to have a clear picture of the various logical chunks that the project or the work can be divided into that engineers on your team can then take ownership of.

So, you want to divide the work into these sensible chunks, and here it's kind of half art, half science, because you don't want to be too vague, like you don't want to just say, "Oh, the chunk of work is that we have to build an API that's kind of too vague."

But on the other hand, you probably don't want to go too deep or too granular.

For instance, if we're talking about front-end engineering and you're building, you know, a brand new product or feature that's got five different pages, and one of those pages is a form, you probably don't want to divide it into each individual input field.

That might be something for the engineer who's going to be taking charge of that page. That might be for them to do in their own design doc of that page or what have you.

So, point is, you want to scope out the work without being too deep or too, you know, far removed.

And here, my guideline typically would be, you know, if we're talking about back-end, maybe scope out the work with, you know, the various API endpoints that you're going to be building or the various, you know, logical pieces of functionality of a feature that you're going to be supporting.

For the front-end, maybe the different pages that you're going to be building out.

Once you've done that, you have to be able to balance a few things at the same time.

So, first of all, you have to make sure that the work gets done, right?

And so, work that is highly critical and that is very difficult has to be prioritized.

And oftentimes, it has to be assigned to the most capable person.

If you've got maybe a senior engineer on the team who would be most qualified to complete this very complicated part of the project and who would be the least risky person to assign this part of the project to, then that might just have to happen.

Now, this actually can go against one of the other things that you need to balance, which is people's happiness, right?

If you're on a team, you want to make sure that your engineers are happy.

And sometimes, you know, some people have preferences.

Maybe another engineer is going to say, "Hey, I would have really wanted to... I would have really liked to work on this part of the feature."

But you have to, you know, use your judgment to see if that would make sense.

And sometimes, those priorities, like the critical work, and assigning it to someone who's able to complete it, is going to, you know, take precedence over someone's preference of what they want to work on.

And then the last thing that you want to balance is your engineers' career trajectories, because... and this might be, I guess, more relevant for managers, but even as a peer, if you're, let's say, you know, the team lead of a project, or the project lead of a project, you want to look out for your peers, and you want to make sure that they're best equipped for their career, to grow in their career, and same for yourself, to be honest.

And so, if you've got one engineer on your team who really needs to focus on proving their technical... their ability to build out technically complex features, then ideally, you can assign to them technically complex features.

If you've got someone who needs to work a little bit more with other teams and other stakeholders, then maybe it might make sense to put them on a part of the project that is going to involve, you know, meetings with backend engineers, or with product managers, or UX designers.

Point is, you have to balance all of these things, right?

The criticality, if that's a word, of parts of the project to ensure that stuff gets done, people's personal preferences, just to make sure that people are happy, and also people's career trajectories, and making sure that you're setting them up for success.

Now, one thing that is sometimes overlooked, that's also important to keep in mind, is just logistical issues.

So sometimes, you know, you'll have some people who have to travel at one point during the quarter, or some people who, for whatever reason, you know, have a commitment that they can't get out of, and that's going to prevent them from attending certain meetings, or they won't be able to attend meetings with other engineers who are in a different time zone at a specific time.

When you've got these logistical issues, you have to also keep them in mind in the way that you distribute the work.

If someone is not going to be able to attend meetings with engineers who are in a completely different time zone late in the day, then maybe, you know, somebody else should do the work that is going to require attending those meetings.

And so, everything that I'm describing here stems from, well, stems from a lot of different experiences, but I'm specifically thinking about one, which was the last project that I worked on when I was a software engineer at Google.

I was leading the project, I was kind of the tech lead of the project, and this was a very large project.

We had engineers in a different time zone in South Korea, so 14 hours ahead.

Lots of work, new engineers, existing engineers, people of different levels.

And so, I basically applied everything that I'm describing here.

You know, I scoped out the work, not too granular, but not too high level, assigned it in a way that made most sense.

So, parts of the project that didn't require too much context in the code base were given to some of these new engineers that were just joining the team.

Parts of the project that were very critical and that needed a lot of context were given to existing engineers who had already been on the team.

Even if they were not necessarily going to benefit from having those technically complex projects under their belt, maybe they would have been better given to a more junior engineer who would have really been able to make use of that, had to make some trade-offs there.

And then finally, the time zone thing.

I made sure to assign work in a way that made sense and respected people's preferences with when they like to work, whether or not they're going to be able to go to meetings with engineers in a different time zone, and so on and so forth.




——————————




Why do you wanna work at insert company name?

So quick pause before I answer this question.

I'm gonna answer this question as if I were currently working at Google and applying to Facebook.

So the question would be, why do I wanna work at GoTo?

So I wanna work at GoTo for three main reasons.

The first one is from a purely technical point of view.

I feel that GoTo is a big tech company, works in a lot of technologies that really excite me, technologies that I've worked a lot on in personal projects. also I realy like interacting with people, especial foreigners, having a tendency to work in multinational company. yes Goto is a good choice.


So basically, all of or a lot of GoTo's technology and products really excites me and interests me.

Now, putting aside the technical stuff for a bit, I'm also really interested or excited about GoTo's culture. like 

Three Zeros Commitments
1. Zero Emissions:Focusing on decarbonization efforts for direct and indirect emissions
2.Zero Waste:Accelerate the reusing, repurposing, recycling and processing of waste
3.Zero Barriers:Focuses on reducing barriers to socioecomonic growth for driver and merchant partners in our ecosystem


I've heard about the, I don't know if it's an unofficial or official motto, move fast and break things.

I don't know if that's kind of an old motto or a recent one or still applicable today, but the point is, I have heard that Facebook has a very unique culture of moving fast, and that's something that really excites me.

Having worked at Google for two years now, even though I've had incredible opportunities, I've worked with incredible people in a very engineering excellence driven company, one thing that has been frustrating at times has been the slowness of some of the engineering projects I've worked on, and from a few peers I've known who worked at Google and now have gone to Facebook, apparently this difference in culture and the velocity with which you can ship out code and ship out projects, launch projects and features is pretty dramatic, the difference between the two companies.

And so I'm really excited about that at Facebook.

Finally, the third thing that is particularly attracting me to Facebook is Facebook's bootcamp experience.

So most of the other companies I've looked at, when you apply to them, you have to apply to a specific team, or for example at Google, you don't apply to a specific team in most cases, but once you pass the interviews, you go through their team matching process and you have to commit to a team before your first day on the job.

At Facebook, I've read a lot about the bootcamp experience and my recruiter told me about it, I'm really excited about being able to try out, actually work on multiple different teams before having to commit to one.

That's something that is incredibly unique, I haven't heard about another company doing that, it's something that really is appealing to me.

And on that note, at the end of the interview, if we have time, I'd love to ask you what your experience was with bootcamp, what you liked about it and how it worked.



==================

So what exactly is GoTo, and how did it get so big?

GoTo is the largest digital ecosystem in Indonesia, with a mission to 'empower progress' by offering technology infrastructure and solutions that help everyone to access and thrive in the digital economy. The GoTo ecosystem provides a wide range of services including mobility, food delivery, groceries and logistics, as well as payments, financial services, and technology solutions for merchants. The ecosystem also provides e-commerce services through Tokopedia and banking services through its partnership with Bank Jago.


GoTo Group is an Indonesian tech company formed in a blockbuster merger between two of the country’s largest start-ups: Gojek and Tokopedia.
The main product of the merger, a powerful super app you can use to book a ride,
buy something or make a payment, is today used by tens of millions.

From day one, we offered multiple different services, like a ride-hailing service or a delivery service.

There’s a saying that if you want to go fast, you go alone; if you want to go far, you go together. So GoTo, basically, is go far, go together.

In May 2021, Two of Indonesia’s largest tech  start-ups have announced one of the biggest mergers ever in the world. These two are famously known as Gojek, a ride-hailing and payment services firm, Tokopedia, an e-commerce firm. The two giants made up what is now known as the GoTo Group and it is one of Southeast Asia’s  most valuable start-ups ever. At the time of the  merger, the company got a public big market valuation.  

what GoTo really is. As mentioned earlier, it is a merger of Indonesia’s biggest tech giants which are Gojek and Tokopedia. 

Gojek, the first company that is a multi-service platform with products and services such as ride-hailing, food delivery, and entertainment services, video streaming platform, and financial services. Gojek is one of the top companies that is changing the world. It is a company that operates in most of the countries in Southeast Asia and is offering a wide array of services. 

Tokopedia is an e-commerce platform, fintech, logistics,  
The Tokopedia Platform and fulfillment business. Like Gojek, Tokopedia  is also a billion-dollar business.

These two together combined makeup one of  the biggest internet companies of Southeast Asia  



———————————————

Hey everybody, welcome to Algo Expert. In this video we're going to answer the following question.

Describe a time when you strongly disagreed with a co-worker about an engineering decision.

How did you go about making the final decision? What did you do after the decision was made?

So there have been many times when I've disagreed with co-workers. When I was at Google, when I was at Facebook, and especially now that I'm running Algo Expert full-time.

And oftentimes these have been pretty big disagreements. Especially now on Algo Expert because the engineering disagreements that we usually have have big product ramifications.

So they end up being product disagreements as well and even, you know, business disagreements, if that makes sense. Now I do think that it's less meaningful for me to focus on a particular disagreement that I've had as much as it is to focus on the general system or process that I follow when we have disagreements. So that's what I'm going to focus on here. And the process that I follow really has three steps. And they're actually kind of inspired by some of the leadership principles at Amazon, if you're familiar with those. So the first step, which is one of the Amazon leadership principles, I think, is to dig deep. To really try to understand every person who's part of the disagreement, all of their ideas, their arguments, and their stances.

You have to understand why someone you're disagreeing with, why they came to the conclusion that they came to. And they have to understand why and how you came to your conclusion. As an example, let's say someone wants to change a piece of code and you don't want to change that piece of code, you disagree with their change. You have to understand why are they changing that piece of code. Is it because they think it'll be better? Okay, probably. But why is it going to be better? Is it because it'll be stylistically better? Okay. Is it because it'll be more performant? Okay, that's another option. Is it because it'll be something that they just prefer? You know, they have a personal preference. Is it because it'll be more consistent with the code base?

You see, there are a lot of different reasons for which someone might think a piece of code is going to be better. You have to understand that. And then once you get to that answer, you continue asking why. You continue dissecting the idea. Well, why do we want to be consistent with the rest of our code base? Why do we want to be more performant? Do we want to be more performant? And again, here in this trivial example, this might seem kind of silly, but in a larger, you know, feature or in a larger decision or disagreement, this might make a lot of sense because someone might have a completely different idea precisely because they think that performance doesn't matter for this particular feature. So super important, dissect people's ideas, try to find loopholes in their arguments just because that'll lead you to a better decision.

And that might sway other people one way or another. Now, one very important aspect of this process here is that you do not want to attack people. You want to attack ideas. Attacking people is toxic, it's unhealthy, it's not professional. You don't want to do that. You want to attack ideas. And what that means is that you have to make sure you're not attacking people, but you also have to make sure that when people are attacking your ideas, you don't take that personally. So these are kind of important, important things that every individual in the disagreement has to kind of internalize for this to actually work. But so that was the first step. You dig deep, really try to understand why people are coming to the conclusions that they're coming to. The second step is to take a step back and to kind of see things from a higher level, from a higher perspective, because oftentimes the environment that you're in, the ecosystem that you're in, maybe the company's current stance or point in time, that might influence the engineering decision.

Now, there have been many times on Algo Expert where we had a disagreement on an engineering decision. If you purely looked at the arguments from both sides without looking at the bigger picture, one person was clearly right. Like, okay, this is, it's better not to do this feature because from an engineering point of view, it'll take far too much time. It'll worsen other parts of the code base. We'll have to use another third party service that we really shouldn't be using, blah, blah, blah. And we agree that that's the better decision. But if you take a step back and you realize that our business's livelihood depends on doing this feature, then well, suddenly, you know, there's an art, there's an additional argument for doing that feature. So got to take a step back sometimes and realize that your organization or your team might have priorities that trump some of the arguments at the purely engineering level.

And then finally, the third part of this process or system that I've got in place, and I think this one is again based on a Amazon leadership principle, or not necessarily based, but I think they have a leadership principle that's similar, is that you want to strongly disagree. You want to do everything that I said, dissect each other's ideas, all of that. But once it comes to making a decision, you have to commit to the decision that gets made. Once the decision is made, rather, you have to commit to that decision. You can't hold grudges, especially if the decision doesn't go your way. If it goes your way, then obviously you'll be happy. But if it doesn't go your way, you have to be able to accept that. You have to commit to the decision that was made, and you have to move forward as if that had been your decision to make sure that the product and the team and everything just goes smoothly.

And of course, I guess here I skipped over one step, which is like, how do you make the decision? Because sometimes someone will change their mind, and that's great. You'll make the decision. Everybody will be happy. But other times, despite all of the arguing and dissecting people's ideas and all that, you still will have a big disagreement. People will still not agree to agree with each other. And in that case, you really have two options. Either you do a majority vote. You vote to see what decisions should be made, and that can work very well. Or you escalate the decision to a decision maker. Typically, that will be someone who's previously appointed, like a manager or your manager's manager, maybe your team lead, tech lead, whatever you want to call it, and they have to make the decision.

If you do escalate to a decision maker, you have to make sure if they weren't part of the disagreement, that they get the full context. You have to present them with all the arguments and everything to make sure that they make a sound decision. But once the decision is made, like I said, commit to the decision. And yeah, this is how I've handled most, if not all, of my disagreements at work, and how I plan to continue handling disagreements at work.



—————————————


Sure! Here’s the extracted English text from the provided content:

---

Hey everybody, welcome to Algo Expert. In this video, we're going to answer the following behavioral interview question. How do you think about receiving and giving feedback? Describe a time when you received tough feedback and/or a time when you gave tough feedback. How did you react to it? How did you give it? So I'm a firm believer in giving constructive feedback by way of radical transparency. Now I realize that the term or the expression "radical transparency" is a bit of a buzzword, but I do think that it's a very useful one, a very applicable one here in the context of giving feedback. You want to be very prompt and direct in giving your feedback or in receiving feedback. There is no better way to improve as a human being and of course as a software engineer, if we're talking about this in the context of software engineering, than by receiving quality constructive feedback that is direct, that doesn't put things vaguely or fluff things up, and that is also prompt, meaning it doesn't come two months, three months after the fact. It comes one week or one day after something has occurred that deserves feedback. Now one additional thing that I want to add here is that I think it's very important when giving feedback to and receiving feedback to give or ask for actionable steps to improve. In other words, it doesn't really help a person who's receiving feedback if you just tell them that they're doing something wrong or doing something poorly without telling them how they can improve, what they can do, what steps they can take to improve. So that's very important, but really I think that this concept of radical transparency is super useful and it's very different from being overly harsh and just mean to people, which is obviously not good and not useful, and very different from being overly nice and hiding things from people just to protect them, so to speak. That doesn't help them. But so as far as examples of when I've received and given feedback, one particular example that comes to mind for when I received feedback was near the start of my career as a software engineer at Google. I think I had been at Google for about two or three months, and one of my peers following a pull request that I had sent out with code basically came up to me and told me, "Hey, Clement, you know, this might sound harsh, but I just want to tell you I think you're writing certain front-end components the wrong way, or not necessarily the wrong way, but in a suboptimal way." And of course, you know, as with all kinds of constructive feedback, which is effectively negative feedback but meant to improve you, I reacted a little bit, you know, had a bit of a tense reaction. You always feel you're kind of like, "Ugh, am I being attacked?" or whatever, but you quickly realize like this is how you improve. And so I had a good conversation with him and, you know, we talked about how I could actually, you know, why were these front-end components that I was writing suboptimal, what was bad, or, you know, what could be improved about them. And, you know, I learned a lot from that. We talked about, you know, stateless components versus stateful components, all that stuff, all that good front-end engineering stuff. And I really improved following that conversation. I noticed it, you know, when I would write future pull requests and future components that the things that this person had told me were true, and I was now applying them, and it was just a great experience. Now, for the time that I gave feedback to someone, this was one of the first interns that I hosted while at Google. And I remember this was a really bright person, really excited, really talented, very good software engineer. One thing that he would do that wasn't particularly good, that could have been improved, was that, especially in our one-on-one meetings, and even in group meetings, he would often, you know, start talking, start asking questions, or start, you know, giving ideas. But he, it kind of felt like he hadn't prepared his thoughts, and he would start rambling on for pretty, like, noticeable periods of time. And so, I told him after I saw him do that, I think, like, three times, so pretty promptly, I told him in one of our one-on-one meetings, "Hey, like, this is something where I think you could improve, that you could improve on." You know, as far as actionable steps, I told him, "Just try to prepare yourself and gather your thoughts a little bit more before you take the microphone, so to speak." And again, as with any time that you give feedback or receive feedback, when it's constructive and it effectively feels like it's negative, you kind of tense up, I could see it in his face, but afterwards, he totally, you know, accepted it, acknowledged it, and at our next one-on-one, he told me that he really appreciated the feedback, he really took it to heart, and what do you know, by the end of the internship, he had completely improved in this regard. And not only had he continued to be a great public speaker, but he was really honing his skills of not, you know, rambling on, not being prepared before speaking. So that was another great example of where direct, radically transparent prompt feedback is very useful.

--- 

If you need further assistance, feel free to ask!


—————————————————————

Hey everybody, welcome to Algo Expert. In this video we're going to answer the following behavioral interview question.

Describe a time when you had to deal with an outage at work. How did you handle the situation? What steps did you take after the issue was resolved?

So, throughout my entire software engineering career, I would say that I've experienced about a handful of real production outages.

Now the one that's most memorable, the one that I want to talk about here, is actually the very first real production outage that I ever experienced.

It happened back in 2017. I had been at Google as a software engineer for a little over six months.

And one afternoon, it was kind of late in the afternoon, I was the last person on my team, or at least the last engineer on my team, at the office.

And I happened to go on the UI, the user interface, of my team's product. I worked on Google Cloud Platform on the front end of a particular Google Cloud Platform product.

And so I go on the website, on the UI, and one of our primary pages was just blank. It wasn't loading, nothing on the screen, just completely blank.

So obviously for a split second, I kind of panicked, "What's going on?" Then I composed myself, and here's how I handled this, what turned out to be a pretty bad production outage.

The first thing that I did is, I wanted to confirm that this was actually a real bug in production and not just something with my computer or my account or something like that.

So I asked a couple people who were around me, these were not my teammates, because like I said, I was the last person from my team at the office,

but a couple of other people who were in proximity to me to go on the link of the page and just to see if they were also experiencing the same thing on their computers, on their accounts.

And yes, they were. So clearly this was a real production issue.

So the second thing that I decided to do was, before alerting anybody else, and I suppose here maybe I should take a step back and say,

at the time, my team didn't have an on-call rotation set up, because if we had had an on-call rotation, the first thing to do here would have been, once I confirmed that this was a real bug,

the first thing to do would have been to flag the bug or the issue to the primary on-call. Just at least have them be aware of what was going on.

We didn't have an on-call rotation at that point in time. We created our on-call rotation a little bit later on.

And this was, by the way, a relatively new Google Cloud Platform product at the time, which is why we didn't have our on-call rotation.

Given that, the first thing that I said I was going to do, or the second thing rather, was I was going to spend five to ten minutes just trying to see if I could debug the issue.

I wanted to see, like, can I fix this without having to alert my teammates who are no longer in the office, without having to alert my manager, who was, I don't know where he was, probably at home.

I spent five to ten minutes trying to debug the issue. Turns out I wasn't able to figure out what the cause of the issue was.

It was a very weird bug, blank page, nothing in the Chrome console. There had been nothing out of the ordinary that day or in the previous days.

So it was really confusing and I just wasn't able to figure it out. So at that point, I did alert the rest of my team after, I would say, about ten minutes.

Because, you know, I think this is one of my philosophies for these types of issues. You never want to be, you don't want to play the hero, right?

If you can, try to figure out the issue within five minutes, but after a certain point, there's no point in hiding this from other people.

The key thing is to fix the issue, not for you to be the hero or for people not to be bothered, if that makes sense.

So after five to ten minutes, alerted my team and fortunately, one of my teammates was actually still in the office, just upstairs getting dinner or something.

So he came down and we started pair programming to try to figure out this bug.

Now, one of the key things also here that we did, which is something that I am a very big proponent of, is even though the situation was pretty stressful,

literally one of the primary pages of our product was down, not working, which meant that the entire product was basically not usable or only half usable.

But so despite the stressful situation, you have to stay calm and you have to also, you know, not point fingers at anybody, not put any blame on anybody.

Because obviously when you're debugging in the moment and everything, it's like, oh, well, this file was poorly written. Why did someone do that?

So I'm not going to go into the bugs here. It's very easy to potentially point fingers and blame people.

I didn't want to do that. And that's just unhealthy in a team in general.

But so we pair programmed, we documented everything that we were doing, keeping our team in the loop.

At that point, my manager was also in the loop. We followed the process that we knew to follow.

Unfortunately, we didn't have some sort of playbook to follow line by line for an outage. And this was a lesson that we learned from this. I'll get into that in a little bit.

But we just documented everything. And after a while, you know, I would say probably after 30 minutes, we decided with my manager, who was chatting with us at this point,

to create an official what's called an OMG at Google, which is basically like an incident report that actually gets flagged kind of at the engineering company level.

And so we did that. We kept the incident report sort of up to date.

And this kind of flags people who are on call and all of Google Cloud Platform and the rest of the company and just followed the procedure there.

Eventually, we figured out what the bug was. It turned out it was something really, really convoluted with Angular, the front end framework.

But that was it. And then we fixed the bug. We had this OMG, this incident report kind of in progress. We eventually closed it.

And, you know, everything was done after that. By the next morning, you know, the new sort of production release or deployment, the bug was fixed.

Now, as for what we did afterwards, we did something that's very common at Google, which I've continued to do even since I've left Google.

And we do it a lot at my current job on Algo Expert, which is to write a postmortem, which is kind of like a document explaining what happened,

the issue, detailing all the steps that were taken to resolve the issue. And most importantly, we answered two questions that I think are crucial to answer after production outage.

Number one, how did we get lucky? And this is a good question to answer because it allows you to determine where there are holes or flaws in your general processes and systems.

For us, we got lucky in the sense that I happened to be at the office late and happened to go on the UI and fall on that page.

Nothing in our systems at that point in time would have flagged that the page was down. And that was clearly an issue.

We had gotten lucky there that we caught the outage quickly and randomly.

And the lesson from that and the thing that we took away from that was that we needed end to end integration tests.

Like I said, we were a fairly new product at the time. We didn't have integration tests, but we obviously, you know, made it a point to create them after this outage.

That was one of our lessons from the postmortem. The second question that I really like to answer in postmortems, which we did, was what could we have done better?

And the thing that we could have done better there was and this was more of a preventative measure was we could have had a written out playbook for how to deal with these kinds of production outages, whom to contact, how to create an incident report, because that was the first time we had all done it.

Or at least me and the engineer pair programming with me. And so, again, another lesson that we took from that it was we need a playbook. And in the couple of weeks following the issue, we actually wrote a, you know, what do you do if you're at work and there's a production outage or what do you do when there's a production outage in general and you have to fix it?

So that's how we handled that incident. That's how I've kind of handled most of the incidents that I've faced since then. And yeah, that's it.


hey everybody,welcome to systems expert. let's dive into the question.hi clement.today i'd like you to design the Uber API,the Uber API OK so.Uber has a lot of different services. it's got the k or ride hailing service or the taxiing service.there's Uber EATS there's Uber pool am i designing the API for all of these services or just one of them.let's just design the corps rides API so,don't worry about Uber rs or Uber pool,OK? the corps rides API. um at first thought it feels like.they're two sides to the Uber product,right when you hail an Uber,you hail it as the passenger,but there's also the the entire driver's side of things.so I think that there's going to be both a passenger facing a pi and a driver facing API. does that make sense,and if so?should i design both of them or just focus on one of them? AH,yeah,I think we should design both of them um because they tie into each other a lot. so let's design both.OK,but so just to clarify as far as the.the user flow or feature functionality that we're supporting here with this API.this is what I have in mind,right? a user takes out their phone,they can hail a ride schedule,a new ber I suppose.then they get matched with the driver. then they get in the car,they can track their ride. they can track the the time to destination all of that.and then finally,when they reach the destination,the ride is complete,and I guess,you know,throughout the entire ride,there might be other.other details um,but is this is this what you had in mind as far as the core functionality that we're supporting? AH yep and uh,when it comes to like the details of what actions exactly happen,what,what order they happen,I nuh,we'll get into this when we start designing the API itself.OK,and then ii guess apart from this core,user flow,do you want me to support things like creating a new ber account? a setting payment preferences submitting driver ratings and tipping drivers that kind of stuff or am I focusing.only on the writing aspect,um,no,don't worry about any of those things. uh,we can skip on that and focus on on the core.fundamental taxing service,OK OK,so then in that case I think that.I will i'll i'll write out both the the passenger facing side of things and the driver facing side of things so i'll just divide my work conceptually speaking into those two things like we said before. and i'll start with the passenger side of things,so i'll write passenger.and then we'll put. maybe here driver,I'm thinking that we are going to have.like quite a few entities,like things,like maybe you know a ride or a passenger as actual entities that we store May be in our database or something,and then we're going to have a few endpoints.you know,like API endpoints that we're going to be hitting just to clarify you want me to write like the signatures. the function signatures of these endpoints.their parameters,the types of their parameters that kind of stuff MM hmm exactly OK.OK,yeah,so then.I guess maybe.the first thing that I should start with is like what happens at the very beginning of the core.user flow.of Uber a passenger takes out their phone and they basically like register themselves for a ride right they. create,they indicate to the to the service that they want to hail a ride and so.the way that I'm thinking about it is basically like behind the scenes,or you know,when they click the button to to book their Uber,they're effectively calling an endpoint that creates.an Uber ride and they're calling AA create ride endpoint ， does that kind of make sense ？哎呀， OK 。 then maybe i'll i'll write this out here in blue so.the the main endpoint that a user would would call here would be create ride.and so this,this implies that we're going to have this entity,the structure that I hinted at before called a ride so.like,you know,in the Uber back end,there's a,there's a thing called a ride that gets created once a user. calls this create ride on point here and I'm trying to think like,what would we want to have in a ride?

what is the information that we need in a ride because basically?a passenger when they're as soon as they create the ride as soon as they book the Uber.they will now have access to this ride object like presumably this create ride and point will return a ride object and this will give them all the info that they need about the ride.you know,this will have stuff like the passenger ID,or I guess the first thing that it would have would be a ride id that it would have.um a ride ID,this would be some sort of unique identifier for the ride,and this would be a string. I think.then there would be AA passenger i dall,right passenger ID. the passenger ID would be the the user ID of the.the person who created the ride and this would be a string,so I suppose here we would likely pass to the create ride and point. 哎呀。 a user ID,user ID.this would be a string. these are all like unique identifiers,and they're created by the backend the user IDS are probably created at the account creation. time,but so.what else do we need in a ride? a ride also has a driver and cause you're,you get a driver as a as a user when you,when you book a ride.i'll probably put a driver ID.and hear him thinking. 我 起。 when you're in a ride,what is the other information that you have? you know how much of the ride is going to cost. or at least like you have an estimated price.you know how far away the you are from your destination,you know?like the driver's name,you know the the driver's rating,so maybe maybe it makes more sense to have like.a driver in fo entity here that contains this driver id so so like here instead of driver ID maybe it's.um,or let me undo and just erase the ID part here instead of driver ID,we have driver in fo. this is,you know,i'll put it in red. this is a driver in fo object or entity.and this driver info here contains not only a unique identifier for the driver,which would be used kind of internally by the APP but.also,the driver's name,the driver's rating,how many rides they've taken or done in the past ET cetera does this make sense so far?yeah. I think it's a good start,OK? so then like I mentioned,we're likely going to want to have,uh,something like.price here or estimated price maybe i'll put estimated cause I think the price like as you travel in the Uber.it changes,and this would be an end t we'd probably have like what would be other important things right. we would have your location.maybe the the the starting location,I wonder if we would have the current location here that would maybe be something that's given in another endpoint because we would need to pull that. frequently and I suppose OK maybe here,I'm jumping the gun a little bit,but.just to to to make sure that we still are abiding by our user flow here,so the passenger creates a ride.this,this.creates a like this right object behind the scenes,but as far as I remember from when i've used Uber.you do not get an instant like max with a driver right 。 sometimes you wait like ten seconds ， even twenty seconds to get an Uber ride is that correct 呀挺。 go up to a couple minutes and depending on how busy the area that you're in this. yeah,so so basically what this implies,I think,is that.create ride.it basically creates this ride object or entity,you know,in the database or wherever. and probably it returns it to the user.but this right object won't necessarily have the driver info immediately,and I think that behind the scenes.this will call some sort of end points like i don't know fine to driver some sort of internal endpoints,so maybe i'll i'll put it here. 嗯 ， this is going to call 。 find.driver and this endpoint is some kind of internal endpoint that can only be called by uber's internal API.and it finds a driver applies some sort of algorithm or formula finds a driver who's free. and I suppose you'll talk about that in the.the driver facing side of the API later,but it finds the

driver's that a driver that's free,and it then attaches the driver to the ride entity. so it's almost like this fine driver here.eventually calls it,eventually calls something like edit ride,so we basically have a credit API for our.for a ride entity and it calls edit ride with um with the driver in fo,does that make sense?no. I think that's good,OK?so one thing I think that it would be really important to have. so here,like I said in the ride,we probably would have like start time.end time uh current duration maybe that would be computed on the UI side of things,so here I think i'll just capture it,is it fine if I just capture it,but with like?like time value s. basically like you know whatever values we need related to the duration of the trip and when the trip was started I.capture in something called time values for now 是。 so that's time values,but then I think one thing that we really need.in a ride is we need the ride status we need.so this will probably be like an enum ride.status.and maybe i'll,i'll put it in red as another like entity or something,or it's an enum like I said. but basically like we need to know if the status,if the ride has been.like is if it's in progress,if it's been cancelled if it's finished right,if it's a created,so maybe i'll.all right,this below here,um,this would be you would have created. you would have a matched,I guess,with a driver.and this here this max here would happen.once you edit the ride,so probably like editing the ride would not only set the appropriate driver info on the ride,but it would also set the appropriate.ride status like initially when you create the ride,the ride status is created once you find a driver and you successfully edit the ride like the internal API successfully edits the ride.then it sets the ride status to max ED. and um.then you would have.in progress.yeah,in progress or maybe like started,I guess then you would have finished and I think the last one would be.cancelled,i'll put it. maybe here.I think these are. these are most of the the statuses that you would expect from a ride,the only thing that I'm trying to think about is. so so yeah,matching is when you've. you've been given a driver started or in progress is when you're actually in the car as the passenger,right?cause your ride doesn't actually start until you're in the car and the driver like presses some sort of button.and again,this will,this will tie back to the driver API but.an yeah,so edits ride here would would set it to match,and then something in the driver API like whatever button they pressed it. that starts the ride once during the car that would set it to start. it are you following me,does this make sense?umm,try to think.we need like,as of the passenger right,we've created a ride.we've gotten.I suppose,like the creater IDE has returned to US. this ride that has no driver at the beginning and that just says like ride status created.but we need to know as soon as we're matched. so I think that once a passenger has created a ride.the client,like their mobile phone basically,is going to have to start pulling the Uber API for this ride.right so like were're,we're gonna have like a get ride and point get ride and point and.this is going to.this is going to continuously be called to get this ride until we've seen that the ride is matched. so here obviously like.our engineers would figure out what the best you know interval for polling is. but I would assume anything between like five and ten seconds you continuously pull until you see that,hey,I have a driver now and I have.a ride status of matched does that make sense. yeah,no,it's good,OK?and so just maybe closing the loop on the create ride on point here. I think I forgot to add,uh,we would have like a pickup point. pick up and we would have a destination and maybe i'll just capture those as like l for location.so

i'll put just dest for destination. i'll put elegant.let me give myself a little bit of space here,but the idea is that's just where the driver has to pick you up and where the ride is going.so that would probably be it for the create ride and point.and then for the get ride,I think that what we would do is we would pass in a ride ID,right a ride ID which we've gotten.from the.create ride endpoint and uh or from the the ride that's been returned to US from the create ride endpoint. and.we would likely have to pass in our user ID as the passenger.because you can imagine that like we need permission ing for this right,we can't just allow any passenger to get access to any ride.i'll add like this would be a string of the right ID and then there would be the userid and I think it's pretty standard in a lot of apis to have like permission ing or access control lists.happen on usu rides,like the back end basically checks something with the usu ride.and so that's how we would do it. yeah,the userid would AH usually come through in the form of an authentication token or something like that.OK. yeah. so then,so then that makes sense.and so then I'm thinking that we'll just need one last.end point which would be well,would we need a delete ride end point? i don't know if we need a delete ride end point,maybe we need it like for internal purposes.for the user,you're never really deleting a ride you,would you would cancel a ride as a user can cancel a ride?but cancelling a ride is just like setting the status to cancelled. so it's effectively editing the ride.um,let's see.maybe,maybe it would make sense to have OK,so I guess there are two ways that we can go about this either. we just expose the edit ride and point.to our clients and basically when a user cancels a ride,they're calling this a tit ride and point under the hood.or we have a wrapper around edit ride which is like cancel ride and um.you know 。 sets it ， calls at it right effectively with a cancelled status 。 does that make sense 呀？ either of them could work OK,so then i'll just go with cance ll ride for now.and um,at this point,the councillor IDE would take,I think it would take the same thing where like you have a ride ID.and a userid. although now that I'm thinking about it.so here for so I'm missing an e,but.when you when you cancel ride,if you're a user,there's only one ride that you can cancel right. you can't just.the only ride that you can cancel is the one that you're in.unless you have,unless you're in multiple but a user can not be in multiple rides at once,right like the way that Uber works. you can only be.in one ride at a time,correct correct.so then,if that's the case.our cancel ride doesn't need to take in anything just the user ID,the user ID always gets passed in from a.permission ing point of view or authentication point of view,but yeah,I think that's all that it needs. um,correct this past user ID and here again,I'm putting string,but maybe this would be a specially formatted string or whatever you implied with the authentication.but 嗯 哼， if we do this ， then I'm wondering like ， can we get away with get ride with out having a ride ID ？ because.so so basically what I'm what I'm saying here is that. when you cancel a ride,you know that you are only part of one ride as the user so like the back end can take this user idea and say,hey,whatever ride this user idea is tied to right now. you know,they do some internal calls.something we cancel that ride,that's the one that we edit ride with.but it's basically the same thing would get ride,right? you don't need to get.a particular ride you just grab the user ID and you say whatever ride is attached to this userid or vice versa whatever. ever ride has a user ID of this value attached to it get that ride,so I think I think that's what I'm going to do.I'm going to remove this right ID and there's going to say that our rides.are are kind of like.they're,they're intrinsically tied to our user IDS. so based on the user ID,the passenger ID you can get any single ride and everything that you need about it.does that make sense? MH,huh,yeah.

I think that works OK,so great,I think that actually.it doesn't simplify that much,but it it prevents US from needing to even do the the permission in gon like whether this user ID matches the right ID or whatever cause we just have the right ID.you know,from this user ID based on like this,this pattern here and by the way here. I guess like this passenger ID here.maybe we would have instead of passenger idea would match like driver info. maybe this would be.passenger and foe. and like this would be a passenger in fo object that has more information about the passenger cause. I think that like drivers can probably see.many rides the passenger has taken,how many stars they have etcetera OK,so do you need me to write that down,or can I just say it out loud?that's,I think that's good. we can,I think,probably move on to the driver's side. I think to passenger's side,you've got. all the bases really covered,OK?okay,great,so then.let's see if i can give myself some space here,if we move onto the driver's side of things.if you're a driver,let's see.AA rider has hailed the ride and you are a driver you now need to get matched to the ride and we said that we find you with this. this fine driver API here.so the fine driver API.is lightly some sort of like internal endpoint.how does it know what driver to get? I guess first of all a driver has to be available right because.sometimes like the drivers are just unavailable,I think they can go in park mode or they can just like,you know,x out of the APP and. they're no longer available for rides,so I think that we need.we need some sort of driver's status that the drivers can set themselves and if. the drivers set themselves as.available,they will like this fine driver API here will effectively like loop them into.the algorithm does that make sense yeah OK so,then here May be all right in red.driver's status,this is probably an an enum driver's status.and this is going to be or be the the statuses we would have so unavailable.unavailable means that you are just not ready to be,you don't want a drive right now whether you are parked or and taking a break or you are done for the day. then there would be available.but available doesn't necessarily mean like we don't want to say,because sometimes you're,you're already in a ride,right? so you probably have an in ride.in ride status.and then maybe the final one would be standby. let's call it standby,standby means that you are,you are available,but you're not in a ride. okay,and so.when a driver gets in the APP,thereby unavailable.they set themselves to stand by once they're ready,once they're ready to be to to to drive.so we'll have a or would it be,or would it be maybe like set? 瑞。 status. and here the said driver's status would take in,I guess it would take in the driver's ID,and here again I'm just going to capture this under this.this kind of nebulous user ID which is our authentication token right and in the passenger like this.this userid here that we have in the passenger API is the one that gets stored in the passenger info or the passenger ID property that I had here.and then the one that's going to be in the driver info that's going to be this user ID. the driver is user ID.and so they said their status.of course,this is used for permission ing for whether they can even set their own status and then it takes in AH. we said a driver's status.driver's status or we implied rather. a driver's status,and i'll just put a May beds here to show that this is this entity.so the driver's status they set themselves to stand by.and um,I guess like,what happens at that point when once there in standby?are they just immediately?I guess they're immediately looped in like May be,maybe there's another,another internal call here. I think it would depend on how you know uber's internal systems work. but maybe there's an internal call.called white find maybe i'll put it in blue.could find ride.find.ride and this would be.this would be kind of the the mirror to find driver,so fine driver runs some sort of

background algorithm asynchronous algorithm that returns the the.most appropriate driver and fine ride basically puts the driver.in some sort of cue right in the back end and eventually they get de cue ED from the cue and they're returned in the fine driver here.does that kind of seem plausible? yeah. that's reasonable,OK? and so I think that.similar to.similar to hear where we continuously pulled like get ride,I think that.here.they haven't so the way we the way i design this is.the passenger is the one that creates the ride,so the passenger has the ride immediately once they create it. the driver has to be served the ride,so find ride here is something that they need to also pull. they probably need to pull it every five to ten seconds or every two seconds. however long,however,is most appropriate,but pretty frequently until they get a ride.so find ride will eventually return like this returns.a ride or a ride ID,right?let's just put a ride for now,cause you can get the ride ID from the ride and.once they have a ride. is it so when you're a new bird driver? can you are you forced to accept a ride like once you're given a ride you just have to take it,or can you reject it?um,I think you have to accept within a certain amount of time. um.OK,so then so we're like within thirty seconds a minute or something. yea,let's say that you have thirty seconds to accept a ride,otherwise it's going to go to the next.available driver.OK. OK,so then in that case,I think what I'm going to do to this fine ride thing here that gets called like internally.or no,I guess the client,the driver client calls this after they've set their driver status to stand by,but this will return either a ride.or like a null or whatever the the the empty value is here.and this,this gets returned when they just haven't been matched to a ride or haven't been like given a ride once they've been given a ride. you get a right object here and there's a countdown,probably internally like on the back end side that starts a thirty second countdown.and the driver has to call another endpoint,which we'll call maybe like um.accept ride.accept oops accept ride,and this is what?this is what will.I guessed it the ride object here like this is what's eventually going to called it ride,and this is what's going to lock the driver into this ride or actually no. let me rephrase.the driver once they get a ride from find ride,they are locked to that ride in the back end system.but it's only once they accept it that it actually mutates the ride with the driver in fo does that make sense 。 yeah ， 哎， OK 。 and so for accepting the ride.I think here I'm wondering if I'm wondering if here we can pull off the same little trick as we did before where you literally just passed in a userid like you could pass in the.the right id that you've been given here. but maybe our back end like matches like here,OK? depending on how you want your backend to work.either the backend temporarily locks like the driver's ID into this ride until they accept it,and if they don't accept it,then it kind of removes it.or it doesn't,in which case you would pass in this ride's ID,the ride ID of this ride in here.does that? does that make sense? yeah,that makes sense. I think we can keep it like this and just assume the backend system knows how to.uh,make the the the matching happen,OK,great.so then at this point,I think that we are almost done with the driver's side of things,because once you've accepted a ride. 幼儿。 在 烧 熟。 edits the ride with not only the driver in fo but the matched a status,and then I guess once you,once the passenger.like gets inside the vehicle.the driver probably.calls edit rides all right all right edit ride here,but this is the same endpoint that we have been talking about since the beginning.at it ride and they call it with um.status started right,and they start the the ride OK at that point. both the passenger and the driver.

are calling the get ride endpoint to continuously pull the ride as the ride is happening.that they get data on how far away the destination is,what the estimated price is and so on and so forth and again.since you would pass in the userid when the passenger calls get ride,they probably get information that's a little bit more relevant to them and when the driver calls get ride with their user ID,they probably get information that's a bit more relevant.to them,you know,more specific to the driver and um I think I think that's about it. I think again.were still dealing with the same endpoints. but both both the passenger and the driver could probably call a tit ride.whenever they're,you know,in the middle of the ride,if they want to change the destination or if they want to cancel it randomly in the middle.and I think that just captures that OK good. there's one additional kind of detail that i'd like you to consider and.that is the location of the driver so as a passenger both before you enter.uh,the car and after you're in the car,you should be able to see in the APP where the car is. um,so how do you? how does that translate into the API OK? so this is like the way that the user just tracks the car on their phone like you see where your driver is at any point in time.not your not the user's own location right,or is that just something that happens like for free through your phone for your own location?yeah,for your own location,let's just assume it doesn't really leave the rider APP,OK?OK ， 时 。 if you need to get the drivers location.this has to be kind of AA bidirectional thing right where the or not necessarily bidirectional,but the user,the passenger.is asking for the driver's location and the driver's returning it to them ， but the thing is this all happens in real time ， right ？哎呀。 yeah,you should be able to pretty seamlessly see the car moving when it's on its way. yeah. yes,then in that case I think that what probably makes the most sense is to have like a long lived web socket connection of sorts.between the the passenger and the driver,so it's something along the lines of,you know,the passenger like basically streams.stream driver location OK and the driver probably has like a counterpart here and points that's like.push push location,push my location.and this. this continuously pushes the location to the.to the passenger,does that make sense? yeah,now I think that's good,and so here I think that the.the push location would likely take,you know,takes in the user idea all the time it takes in the.so this is string.it takes in a location now. the only thing is.how would the does the stream driver location need a driver ID no,I think that here again.we do the same trick of we. we literally only use like user IDS and all of these calls we only use user IDS,so here this only takes.a user idea or something when you first like create the long lived connection and based on the ride that this user idea is tied to based on the driver.it's tied to that ride. you do those sort of like matching is that,does that seem reasonable? yeah,I think that's good.OK. so then I think that's how I would do. that's how I would do the the location screaming,and I'm trying to think like,is there anything else?at that point,like once you reached the end of the ride.the driver is likely the one who.like the driver probably has an end ride end point which is either.a wrapper around edit ride or it's literally the edit ride and point,and they just set the status to finished and then they.set their driver's status tou m. standby um,yeah,I think that makes sense um. we have a few minutes left,so I was wondering if you could kind of walk me through.AH,your thought process if we were to try to design Uber pool on top of the existing entities that you kind of came up with here,OK? so for Uber pool.Uber pool is identical to the normal Uber taxing service except that.you have like multiple passengers in the

car,so it's slightly more complicated than that simply due to the fact that. now a single driver,i can have multiple different rides going on at the same time because each ride has a start point and end point.a time of creation,right? all right? because Uber pool,Uber pool is not just like multiple passengers being picked up from the same location. they're a different.locations and they have different destinations. yeah,right,OK ay.o kay,o kay. so that that does.that does make things a little bit trickier,I'm wondering.so let's see,I feel like our ride entity is like the most important thing in this entire equation.would we be able to pull off just having?like multiple instead of having so,you still have one driver.but here remember,this was supposed to be passenger in fo instead of having only one passenger in fo you have a repeated field. of passenger info s plural,but the only thing is if you have a repeated field like you have,you have to have multiple destinations,multiple start points.I guess like your users,your passengers could still.like when they make the call to get ride.they get served their appropriate destination and start point,but then again it's like.they. they like one passenger's.finished ride might be another passenger's in progressed ride right correct,OK so then?maybe it doesn't make sense to.have like multiple passengers on a ride maybe for Uber pool.I'm thinking that for Uber pool,what we could do.is we have like a pool ride entity.a pool ride entity.and the pool right entity has like. it has a driver in fo.which might be redundant because we have the driver info on these rides,but then the key point is it has like a repeated field of rides,like the rides is.is,you know,like an array of this ride entity here,I'm writing in pseudocode,but if you have so every passenger creates their ride.sort of in the same way like presumably they can use this endpoint. but then there's a wrapper. there's an Uber pool wrapper around it.that attaches these rides to this repeated field here.and presumably there's extra information on the pool ride related to like maybe the MM.the you know which destination is going to be reached first and so on and so forth does that seem like it's AA better direction than having?like all of the passengers live on on the single right object here,yeah,I think ideally the right,the right object already does a lot for US,so I think it makes sense to have a this higher level construct that makes use of what we already have.in order to to have this complex functionality on top of it 呀。 OK,so then I think yeah that that that's the direction,then that I would go in and based on what you're saying. I think that would be the the safer or cleaner direction it would lead to less.the least amount of super convoluted stuff,but um,what else? what else would you like me to design about the the Uber pool API is there anything?because like,is there any other functionality apart from?from the same functionality,but at the pool level um so. maybe we can think about ha um,what that looks like from the driver's side um,because now they.themselves er on multiple rides,so even when they are already driving,they can still accept new rides.uh,yes,so would that? how would that change kind of the drivers aid of things? OK,interesting? so it's. I wonder like,and here maybe i don't know enough about how Uber pool works,but I wonder.if a driver maybe has like a capacity in their car and until they've reached their capacity in their car,they can be in ride,but they have maybe there's like another driver's status that's like in ride.but accepting more,you know,like still available for pick,pick up. and if that's the case,you're continuously.you know,hitting this fine ride end point and you get these rides. you know,these rides that you are then going to attach to your Uber pool ride and the rider can keep accepting them.then eventually,once you are,you know,once you have like,uh.

i'll put in ride.in ride d one but d one to say that like you can not pick up anymore,then you just no longer call this ride and you just go on with your,with your current Uber pool.okay,yeah,I think that s reasonable i don t.really have any more questions for you,so I think at this point,uh. it's good thanks clement,OK? cool,thank you.with that,I hope that you found this video informative and will see you in the next one.
缩略图
1

2

3

4

5

6

7

8

9


—————————————————————


Hey everybody, welcome to Algo Expert. In this video, we're going to answer the following behavioral interview question.

Describe a time when you went out of your comfort zone.

Why did you do it? What lessons did you learn from the experience?

So one time that I went out of my comfort zone was back during the summer of 2018.

I had decided to host for the very first time a pair of engineering interns at Google.

This was my very first managerial experience.

And I was very excited about it because it was something that I'd always wanted to do, but it was something very new to me.

So it was out of my comfort zone in that I had never been in a managerial position before.

And I had been warned by my manager, by other people who had hosted interns in the past, that this was going to be a non-trivial endeavor.

It wasn't going to be easy.

And also, I chose to host what are called engineering practicum interns at Google, where these are interns who are a bit younger.

They are, I think, freshmen, incoming sophomores or incoming juniors.

So a bit earlier on in their career, and they come in pairs, not just a single intern.

So it was definitely going to stretch me out of my comfort zone.

And the reason I did it was because not only did I want to do it, like I said, I had always wanted to try this out, to try to be a manager, to see if that was something that I was going to really enjoy.

But also, I'm a firm believer that one of the best ways to grow is to push yourself out of your comfort zone, like to challenge yourself with new things, things that you haven't done before.

It's a great way to test, to see if you like certain things.

It's a great way to just learn new skills and grow.

And so that's why I wanted to do it.

Now, what I learned from it, I think probably two big lessons that I that I drew from the experience.

The first one was that management isn't easy.

I know that engineers especially have a tendency to kind of look down upon management to say that management is a bit easy.

It's it's sometimes useless.

That's that's the feeling that I felt from a lot of engineers that I've met.

But truthfully, being in a managerial position, I realized that management isn't easy.

And here I'll quote something that my my manager, my current manager, told me, which is that engineering is easy.

People are hard.

So management, by definition or by extension, is hard.

And one of the reasons that it's hard is you have people who are dependent on you and your actions are almost directly going to determine multiple people, in my case, the two interns I was hosting, multiple people's experiences at work and basically happiness at work.

And one last thing I'll say about this is it was particularly difficult when I had to do, let's say, one on one meetings with with my interns.

It was particularly difficult to to deal with sometimes my own like bad days.

Like, for example, if I had a bad day as an engineer, I could just go to my computer, put my headphones on and code.

And I didn't really have to talk to anybody except maybe in a couple of meetings or in a pair programming session.

But when you're a manager, you can't have you can't have a bad day and go to a meeting in a one on one with a direct report and and show that you're having a bad day.

Right. Because you have to serve them.

You can't kind of leak your bad mood on them.

So that was something that was pretty difficult.

But anyway, I did the gate. The second big lesson that I learned from the experience was that you you quickly realize that there's no adult in the other room to save you.

So what I mean by that is when you work at a big company, especially a big tech company, you often have this feeling of security, at least as a as an engineer or as just an individual contributor.

You often have this feeling of of mental security where if something goes wrong or if you don't have the answer to something or if you don't know what to do, somebody else will be there to save you.

Somebody else will be there to give you a parachute to give you the answer that you're looking for.

When you put yourself in a managerial position, at the very least when you're when you're the manager of of an intern or of a pair of interns, there is nobody else behind you to pick up your messes.

If I messed up the projects that I assigned to my interns, if I messed up the one on ones with my intern, there wasn't anybody else who was responsible for them.

And that's a pretty that's a pretty frightening realization.

It's also a very empowering one.

And I've just remembered it ever since.

And now whenever when I kind of see my own managers now and leaders in companies in general in a bit of a different light, and I realize the difficulty that they might be experiencing when they're making decisions, because oftentimes

there's just nobody else in the other room to save them or to tell them what the best decision is in a certain scenario, for example.